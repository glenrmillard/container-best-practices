<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<!--[if IE]><meta http-equiv="X-UA-Compatible" content="IE=edge"><![endif]-->
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 1.5.4">
<title>Creating Images</title>
<link rel="stylesheet" href="http://www.projectatomic.io/stylesheets/application.css">
</head>
<body class="article">
<div id="header">
</div>
<div id="content">
<div class="sect1">
<h2 id="create">Creating Images</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The base unit of creating an image is the Dockerfile itself.  This section
focuses on the instructions that make up a Dockerfile.</p>
</div>
<div class="paragraph">
<p>This chapter will not cover every Dockerfile instruction available but instead
will focus on specific ones that we want to re-enforce to those who develop
Dockerfiles.  Docker has published a
<a href="https://docs.docker.com/engine/reference/builder/">reference guide</a> already
covering each of the Dockerfile instructions. In addition, upstream docker has a nice description of <a href="https://docs.docker.com/engine/articles/dockerfile_best-practices/">best practices</a> for Dockerfiles. It
describes the various instructions that can be used to compose a Dockerfile and their best usage. Familiarize yourself with these
recommendations.</p>
</div>
<div class="sect2">
<h3 id="_creating_base_images">Creating Base Images</h3>
<div class="sect3">
<h4 id="_choosing_base_image">Choosing Base Image</h4>
<div class="paragraph">
<p>Images that have no parent are called base images. Docker image usually have their own root filesystem with an operating system installed. So when you want to create a new image, it either has to be based on an image that actually provides an operating system or you will need to create this layer in your image. The only difference to this are super minimal images that instead of an operating system provide only a single binary as described later in the text.
There is a wide variety of base images already available on Docker Hub, so the simplest solution is to use one from there. Here are a few things that should help you determine which base image will fit your needs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Linux distribution - Your personal preference and perhaps experience is a reason why to choose a certain distribution rather than another one. However, you should definitely consider whether your containerized application requires specific libraries or tools from a specific system.</p>
</li>
<li>
<p>Image size - Base images usually contain a minimal operating system with a set of tools needed for basic operations. To preserve your environment small and efficient, size should also be taken into account when picking the right base image. The size varies; you can take advantage of super small base images, such as 2MB busybox, or use a standard minimal operating system, such as Fedora or CentOS that are up to 200MB in size.</p>
</li>
<li>
<p>Updates - Not all community images are necessarily rebuilt on a regular basis or when security vulnerabilities are addressed. You should therefore consider using base images from "official repositories" on Docker Hub, and confirm their update policy in advance.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_creating_base_image">Creating Base Image</h4>
<div class="paragraph">
<p>Once you&#8217;ve considered all options and decided to create your own base image, the process will mostly depend on the distribution you chose. Note that the major distributions have their source files available on GitHub so you still might want to consider creating an issue or opening a pull request to suggest a change in the feature set or any adjustment.
<a href="https://docs.docker.com/engine/userguide/eng-image/baseimages/">Docker documentation</a> suggests two approaches to creating a base image, using tar and building an image "FROM scratch".</p>
</div>
<div class="sect4">
<h5 id="_using_tar">Using tar</h5>
<div class="paragraph">
<p>Using the tar tool is a simple way how to build a base image. As a prerequisite, you will need to set up a directory structure for chroot with all items that you wish to be part of the base image. There are various tools that might help you with this, for example <em>debootstrap</em> for Debian systems or <em>supermin</em> for RPM-based systems.</p>
</div>
<div class="paragraph">
<p>Once you have your chroot directory ready, it is as simple as running:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># tar -C &lt;chroot_dir&gt; -c . | docker import - &lt;new_image_name&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that docker provides a set of scripts for base image creation that take advantage of tar: <a href="https://github.com/docker/docker/tree/master/contrib">https://github.com/docker/docker/tree/master/contrib</a>. Well known distributions then use their own build systems that usually also utilizes tar. For example Fedora&#8217;s <a href="https://fedoraproject.org/wiki/Koji/BuildingImages?rd=Koji/KojiLiveCDHowTo#Building_Disk_Images">koji</a>.</p>
</div>
</div>
<div class="sect4">
<h5 id="_from_scratch">FROM scratch</h5>
<div class="paragraph">
<p>"scratch" is a special repository in the Docker Hub registry, created using an empty tarball. It is not meant to be pulled or run, and at any such an attempt you will most likely encounter this message: <em>'scratch' is a reserved name</em>.
Using scratch is ideal for creating extremely minimal images, for example for containerizing single binaries. An example is available from <a href="https://docs.docker.com/engine/userguide/eng-image/baseimages/">Docker documentation</a>.
scratch is also very handy for creating standard distribution base images. But as with tar, you&#8217;ll first need to prepare a directory structure for chroot. After that, just add the directory in your Dockerfile as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>FROM scratch
ADD &lt;chroot_dir&gt; /
CMD ["/bin/bash"]</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_layered_images">Creating Layered Images</h3>
<div class="sect3">
<h4 id="_creating_component_or_application_images">Creating Component or Application Images</h4>

</div>
</div>
<div class="sect2">
<h3 id="creating_concise">Create small and concise images</h3>
<div class="paragraph">
<p>It is preferable to create small and concise images whenever possible.  This can
be highly dependent on the application you are containerizing, but there are
techniques to help you accomplish this.  The following sections cover these
techniques.</p>
</div>
<div class="sect3">
<h4 id="_clear_packaging_caches_and_temporary_package_downloads">Clear packaging caches and temporary package downloads</h4>
<div class="paragraph">
<p>Package managers can typically generate lots of metadata and also store downloaded content into a cache of
sorts. To keep images and layers as small as possible, you should consider clearing out these caches of downloaded
content.  Note how the following example ends with a <em>yum -y clean all</em> which removes deletable yum content.</p>
</div>
<div class="listingblock">
<div class="title">A singular RUN instruction performing multiple commands</div>
<div class="content">
<pre class="highlight"><code>RUN yum install -y epel-release &amp;&amp; \
    rpmkeys --import file:///etc/pki/rpm-gpg/RPM-GPG-KEY-CentOS-7 &amp;&amp; \
    yum install -y --setopt=tsflags=nodocs bind-utils gettext iproute\
    v8314 mongodb24-mongodb mongodb24 &amp;&amp; \
    yum -y clean all</code></pre>
</div>
</div>
<div class="paragraph">
<p>There are several package managers beyond yum that should be of note: dnf, rvm, gems, cpan, pip. Most of these
managers have some form of a clean up command that will handle excess cache created while performing their package management duties.</p>
</div>
<div class="paragraph">
<p>Below are examples pictured for dnf and rvm:</p>
</div>
<div class="listingblock">
<div class="title">dnf cleanup example</div>
<div class="content">
<pre class="highlight"><code>RUN rpm -ivh https://dl.fedoraproject.org/pub/epel/epel-release-latest-7.noarch.rpm &amp;&amp; \
    dnf -y install nodejs tar sudo git-all memcached postgresql-devel postgresql-server \
    libxml2-devel libxslt-devel patch gcc-c++ openssl-devel gnupg curl which &amp;&amp; \
    dnf clean all &amp;&amp; \</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Ruby(rvm) cleanup example</div>
<div class="content">
<pre class="highlight"><code>RUN /usr/bin/curl -sSL https://rvm.io/mpapis.asc | gpg2 --import - &amp;&amp; \
    /usr/bin/curl -sSL https://get.rvm.io | rvm_tar_command=tar bash -s stable &amp;&amp; \
    source /etc/profile.d/rvm.sh &amp;&amp; \
    echo "gem: --no-ri --no-rdoc --no-document" &gt; ~/.gemrc &amp;&amp; \
    /bin/bash -l -c "rvm requirements &amp;&amp; rvm install ruby 2.2.4 &amp;&amp; rvm use 2.2.4 --default &amp;&amp; \
    gem install bundler rake &amp;&amp; \
    gem install nokogiri --use-system-libraries &amp;&amp; \
    rvm cleanup all &amp;&amp; yum clean all &amp;&amp; rvm disk-usage all"</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the above example, notice the yum clean all called after rvm, this is because some package managers like rvm rely on others (like yum
in this case) to help perform their duties. Make sure to examine your container&#8217;s layers sizes to help determine where you can
eliminate excess size and keep it&#8217;s footprint size to a minimum.</p>
</div>
<div class="paragraph">
<p>Here is a listing of some package managers and the applicable cleanup commands:</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 1. Package Managers</caption>
<colgroup>
<col style="width: 50%;">
<col style="width: 50%;">
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Package Manager</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Cleanup Command</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">yum</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">yum clean all</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dnf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">dnf clean all</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rvm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rvm cleanup all</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">gem</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">gem cleanup</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cpan</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rm -rf ~/.cpan/{build,sources}/*</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pip</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">rm -rf ~/.cache/pip/*</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">apt-get</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">apt-get clean</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="_clearing_package_cache_and_squashing">Clearing package cache and squashing</h5>
<div class="paragraph">
<p>If you squash your images after manual building or as part of an automated build process, it is not necessary to clean cache in every single relevant instruction/layer as the intermediate layers affect the previous ones in this case.</p>
</div>
<div class="paragraph">
<p>Simple example Dockerfiles below would both produce the same image if they were squashed:</p>
</div>
<div class="listingblock">
<div class="title">Cache cleanup in a separate instruction</div>
<div class="content">
<pre class="highlight"><code>FROM fedora
RUN dnf install -y mariadb
RUN dnf install -y wordpress
RUN dnf clean all</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Cache cleanup chained with the install command</div>
<div class="content">
<pre class="highlight"><code>FROM fedora
RUN dnf install -y mariadb wordpress &amp;&amp; dnf clean all</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, without squashing, the first image would contain additional files and would be bigger than the second one.</p>
</div>
<div class="listingblock">
<div class="title">Size comparison</div>
<div class="content">
<pre class="highlight"><code># docker images
REPOSITORY          TAG                 IMAGE ID            CREATED              VIRTUAL SIZE
example             separate            54870d73715f        21 seconds ago       537.7 MB
example             chained             6a6156547888        About a minute ago   377.9 MB</code></pre>
</div>
</div>
<div class="paragraph">
<p>Therefore, it is a good practice to write Dockerfiles in a way so that others can use it as a valid reference and are always able to reproduce the build. To ensure this, you should <strong>clean cache in every layer</strong> where applicable. In general, you should always aim to create images that are small and concise regardless of whether the final image is squashed or not.</p>
</div>
<div class="paragraph">
<p>Read more about suqashing and its repercussions in the <a href="#squashing">Squashing layers</a> section.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_remove_unnecessary_packages">Remove unnecessary packages</h4>
<div class="paragraph">
<p>In some cases, your image can end up with several packages that are not necessary to support the runtime of your
application.  A good example is when you actually build your application from source during the build of the image
itself.  Typically, when you build an application, you will pull in development (-devel) packages as well as
toolchain based packages like make and gcc.  Once your application is built, you may no longer need these packages
for runtime depending on how your application links to libraries.</p>
</div>
<div class="paragraph">
<p>Depending on your application and which packages you added to your image, you might need to iteratively attempt to
remove packages checking to make sure your application still works.  One suggestion would be to remove big parts of the
toolchain.  And then use your package manager&#8217;s command to clean up unused packages.  In the case of <em>yum</em>, you can
remove unneeded packages like so:</p>
</div>
<div class="listingblock">
<div class="title">Removing unnecessary packages with yum</div>
<div class="content">
<pre class="highlight"><code># yum autoremove</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should run this command in an interactive shell (docker run -it --rm &lt;image&gt; /bin/bash) initially so you can
get a feel for which packages will be removed.  One upside to doing so is that you can then test run your application
from the interactive shell to make sure it still works.</p>
</div>
</div>
<div class="sect3">
<h4 id="_installing_documentation">Installing Documentation</h4>
<div class="paragraph">
<p>It is generally considered good practice to keep your images as small as possible.  Above we have discussed that
package manager caches should be cleared to reduce image sizes.  You can also reduce image size by limiting the
documentation being installed.  If you package manager supports such a thing and then you have no expectations
for users to use a shell to interact with your image, this might significantly reduce the size of your image.</p>
</div>
<div class="paragraph">
<p>Yum has an optional flag to not install documentation.  The following example shows how to set the flag.</p>
</div>
<div class="listingblock">
<div class="content">
<pre>RUN yum install -y mysql --setopt=tsflags=nodocs</pre>
</div>
</div>
<div class="paragraph">
<p>Note that the <strong>nodocs</strong> flag is used in some base images, for example CentOS and Fedora, and this setting gets
inherited by the child layers. This can cause problems in case you want to include documentation deliberately in your
 layered image.</p>
</div>
<div class="paragraph">
<p>In this case, if you wish to have the documentation installed for <strong>packages from your single layer only</strong>, you have to
empty the <strong>tsflags</strong> option as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>RUN yum -y install docker --setopt=tsflags=''</pre>
</div>
</div>
<div class="paragraph">
<p>If you wish to have the documentation installed for <strong>packages from your single layer and the parent layers</strong>, you need
 to reinstall the packages with the empty <strong>tsflags</strong> option as follow:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>RUN yum -y reinstall "*" --setopt-tsflags='' &amp;&amp; yum install docker --setopt-tsflags=''</pre>
</div>
</div>
<div class="paragraph">
<p>In case you need to have documentation included for <strong>every package from every single parent or child layer</strong>,
the <strong>/etc/yum.conf</strong> file needs to be edited as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>RUN [ -e /etc/yum.conf ] &amp;&amp; sed -i '/tsflags=nodocs/d' /etc/yum.conf || true
RUN yum -y reinstall "*"
RUN yum -y install &lt;package&gt;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="squashing">Squashing layers</h4>
<div class="paragraph">
<p>Each instruction you create in your Dockerfile results in a new image layer being created. Each layer brings additional
data that are not always part of the resulting image. For example, if you add a file in one layer, but remove it in
another layer later, the final image&#8217;s size will include the added file size in a form of a special "whiteout" file
although you removed it. In addition, every layer contains separate metadata that add up to the overall image size as
well. So what are the benefits of squashing?</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Performance</strong> - Since all layers are copy-on-write file systems, it will take longer to build the final container
from many layers. Squashing helps reduce the build time.</p>
</li>
<li>
<p><strong>Image size</strong> - Similarly, since an image is actually a collection of other images, the final image size is the sum of the sizes of component images. With squashing, you can prevent these unwanted size additions.</p>
</li>
<li>
<p><strong>Organization</strong> - Squashing also helps you control the structure of an image, reduce the number of layers and organize images logically.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>However, Docker does not yet support squashing natively, so you will have to work around it by using alternative
approaches, some of which are listed below.</p>
</div>
<div class="sect4">
<h5 id="_docker_save">docker save</h5>
<div class="paragraph">
<p>You can use <em>docker save</em> to squash all the layers of your image into a single layer.  The <em>save</em> command
was intended for this use, so this happens to be a side effect of the process. This approach,
however, is not very practical for sharing as the user will be able to only download
the whole content and cannot take advantage the caching. Note that the base image layer will be included
as well and might be several hundreds of megabytes in size.</p>
</div>
</div>
<div class="sect4">
<h5 id="squash_tools">Custom Tools</h5>
<div class="paragraph">
<p>You will surely find a lot of utilities on the internet that facilitate layer squashing.
We recommend taking advantage of Marek Goldmann&#8217;s <a href="https://github.com/goldmann/docker-squash">docker-squash</a>, which
automates layer squashing and which is maintained and has been tested by the community.</p>
</div>
</div>
<div class="sect4">
<h5 id="_repercussions_of_squashing">Repercussions of squashing</h5>
<div class="ulist">
<ul>
<li>
<p>When you squash an image, you will lose the history together with the metadata accompanying the layers.</p>
</li>
<li>
<p>Without the metadata, users building an image from a layered image that has been squashed are losing the idea that it happened.</p>
</li>
<li>
<p>Similarly, if you decide to include the parent layer from which your image is built into the resulting squashed image, you ultimately prevent others from seeing that this happened.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Look at the mongodb example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># docker images openshift/mongodb-24-centos7
REPOSITORY                               TAG                 IMAGE ID            CREATED             VIRTUAL SIZE
docker.io/openshift/mongodb-24-centos7   latest              d7c0c18b0ae4        16 hours ago        593.3 MB</code></pre>
</div>
</div>
<div class="paragraph">
<p>Without squashing, you can see complete history and how each of the layers occupies space.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># docker history docker.io/openshift/mongodb-24-centos7:latest
IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT
d7c0c18b0ae4        About an hour ago   /bin/sh -c #(nop) CMD ["run-mongod"]            0 B
63e2ba112add        About an hour ago   /bin/sh -c #(nop) ENTRYPOINT &amp;{["container-en   0 B
ca996db9c281        About an hour ago   /bin/sh -c #(nop) USER [184]                    0 B
8593b9473058        About an hour ago   /bin/sh -c #(nop) VOLUME [/var/lib/mongodb/da   0 B
5eca88b7872d        About an hour ago   /bin/sh -c touch /etc/mongod.conf &amp;&amp; chown mo   0 B
9439db8f40ad        About an hour ago   /bin/sh -c #(nop) ADD dir:f38635e83f0e6943cd3   17.29 kB
12c60945cbac        About an hour ago   /bin/sh -c #(nop) ENV BASH_ENV=/usr/share/con   0 B
e6073f9a949f        About an hour ago   /bin/sh -c #(nop) ENV CONTAINER_SCRIPTS_PATH=   0 B
619bf2ae5ed8        About an hour ago   /bin/sh -c yum install -y centos-release-scl    342.6 MB
ab5deeccfe21        About an hour ago   /bin/sh -c #(nop) EXPOSE 27017/tcp              0 B
584ded9dcbca        About an hour ago   /bin/sh -c #(nop) LABEL io.k8s.description=Mo   0 B
17e3bcd28e07        About an hour ago   /bin/sh -c #(nop) ENV MONGODB_VERSION=2.6 HOM   0 B
807a1e9c5a7b        16 hours ago        /bin/sh -c #(nop) MAINTAINER SoftwareCollecti   0 B
28e524afdd05        10 days ago         /bin/sh -c #(nop) CMD ["/bin/bash"]             0 B
044c0f15c4d9        10 days ago         /bin/sh -c #(nop) LABEL name=CentOS Base Imag   0 B
2ebc6e0c744d        10 days ago         /bin/sh -c #(nop) ADD file:6dd89087d4d418ca0c   196.7 MB
fa5be2806d4c        7 months ago        /bin/sh -c #(nop) MAINTAINER The CentOS Proje   0 B</code></pre>
</div>
</div>
<div class="paragraph">
<p>See how the history and size changes after squashing all layers in a single one (using the script <a href="#squash_tools">above</a>):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code># docker history docker.io/openshift/mongodb-24-centos7:squashed
IMAGE               CREATED             CREATED BY          SIZE                COMMENT
90036ed9bd1d        58 minutes ago                          522.1 MB</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>One of the biggest benefits of using layers is the posibility to reuse them. Images are usually squashed into a single big layer, which does not allow for pushing partial updates in individual layers; instead, the whole image needs to be pushed into the registry upon a change. The same applies to pulling the image from the registry.</p>
</li>
<li>
<p>Some users might rely on suqashing when it comes to sensitive data. Be cautios because squashing is not meant to "hide" content. Even though squashing removes intermediate layers from the final image, information about secrets used in those layers will stay in the build cache.</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_chaining_commands">Chaining Commands</h4>
<div class="paragraph">
<p>In general, having fewer layers improves readability. Commands that are chained together become a part of the
same layer. To reduce the number of layers, chain commands together. Find a balance, though, between a large
number of layers (and a great many commands), and a small number of layers (and obscurity caused by brevity).</p>
</div>
<div class="paragraph">
<p>A new layer is created for every new instruction defined. This does not necessarily mean that one instruction
should be associated with only one command or definition.</p>
</div>
<div class="paragraph">
<p>Ensure transparency and provide a good overview of the content of each layer by grouping related operations
together so that they together constitute a single layer. Consider this snippet:</p>
</div>
<div class="listingblock">
<div class="title">Chained Dockerfile instruction</div>
<div class="content">
<pre class="highlight"><code>RUN yum install -y --setopt=tsflags=nodocs \
    httpd vim &amp;&amp; \
    systemctl enable httpd &amp;&amp;
    yum clean all</code></pre>
</div>
</div>
<div class="paragraph">
<p>Each command that is related to the installation and configuration of <code>httpd</code> is grouped together
as a part of the same layer. This meaningful grouping of operations keeps the number of layers low
while keeping the easy legibility of the layers high.</p>
</div>
<div class="sect4">
<h5 id="_using_semi_colons_vs_double_ampersands">Using semi-colons (;) vs double ampersands (&amp;&amp;)</h5>
<div class="paragraph">
<p>In the RUN instruction of Dockerfiles, it is common to string together multiple commands for efficiency.  Stringing
commands together in the RUN instructions are typically done with ampersands or semi-colons. However, you should
consider the implications of each and their usage.  The following examples illustrate the difference.</p>
</div>
<div class="listingblock">
<div class="title">Using semi-colons as instruction conjunctions</div>
<div class="content">
<pre class="highlight"><code>RUN do_1; do_2</code></pre>
</div>
</div>
<div class="paragraph">
<p>This sort of conjunction will be evaluated into do_1 and then do_2.  However, using the double
ampersands results in a different evaluation.</p>
</div>
<div class="listingblock">
<div class="title">Using double ampersands as conjunctions</div>
<div class="content">
<pre class="highlight"><code>RUN do_1 &amp;&amp; do_2</code></pre>
</div>
</div>
<div class="paragraph">
<p>The ampersands change the resulting evaluation into do_1 and then do_2 <em>only if do_1 was successful</em>.</p>
</div>
<div class="paragraph">
<p>The use of the double ampersands as conjunctions is probably a better practice in Dockerfiles because
it ensures that your instructions are completed or the build will fail.  If the build were to continue
and you had not closely monitored the build (or its results), then the image may not be exactly
as you desired.  This is particularly true with automated build systems where you will want any
failure to result in the failure of the build itself.</p>
</div>
<div class="paragraph">
<p>There are certainly use cases where semi-colons might be preferred and possibly should be used.
Nevertheless, the possible result of an incomplete image should be carefully considered.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_locales">Locales</h4>

</div>
</div>
<div class="sect2">
<h3 id="_labels">Labels</h3>
<div class="paragraph">
<p>Labels in Dockerfiles serve as a useful way to organize and document metadata used to describe an image.  Some labels are only descriptive
by nature, like  <em>Name</em> whereas others, like <em>RUN</em> can be used to describe action-oriented metadata.  Labels are often leveraged by applications, like
<a href="https://github.com/projectatomic/atomic">atomic</a>, to help the image run as the author intended.  They can also for purely descriptive
purposed and can viewed manually with the <em>docker inspect &lt;image_name&gt;</em> command.</p>
</div>
<div class="paragraph">
<p>The authoritative source for labels
is the  <a href="https://github.com/projectatomic/ContainerApplicationGenericLabels">Container Application Generic Labels</a> git repository.</p>
</div>
<div class="sect3">
<h4 id="_when_are_they_required">When are they required?</h4>
<div class="paragraph">
<p>Labels are never required per-se unless your build system or lifecycle management process requires them.
However, the use of labels is highly recommended for a number of reasons:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>As mentioned above, many container related tools can use the label metadata in meaningful ways often
contributing to a better user experience.</p>
</li>
<li>
<p>The label metadata is always visible when inspecting the image.  Therein, users can at least see the
metadata even if their tooling does not make specific use of it.  For example, the RUN label basically
documents how you, as the author of the Dockerfile, expect this image to be run.</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_descriptive_labels">Descriptive labels</h4>
<div class="paragraph">
<p>The descriptive labels usually are alpha-numeric strings used to describe some aspect of the image itself.  Examples, might be
the version and release labels which could theoretically just be integer based.
The following table describes labels that are meant to be purely descriptive in nature.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 2. Descriptive labels</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Label</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">changelog-url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL of a page containing release notes for the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>TBD</em></p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">name</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Name of the Image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"rhel7/rsyslog"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">version</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Version of the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"7.2"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">release</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Release number of the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"12"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">architecture</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Architecture for the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"x86_64"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">build-date</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Date/Time image was built as <a href="https://tools.ietf.org/html/rfc3339">RFC 3339</a> date-time</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"2015-12-03T10:00:44.038585Z"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">vendor</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Owner of the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"Red Hat, Inc."</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL with more information about the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>TBD</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Summary</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Brief description of the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>TBD</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Description</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Longer description of the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>TBD</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">vcs-type</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The type of version control used by the container source. Generally one of git, hg, svn, bzr, cvs</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"git"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">vcs-url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">URL of the version control repository</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>TBD</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">vcs-ref</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">A 'reference' within the version control repository; e.g. a git commit, or a subversion branch</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"364a&#8230;&#8203;92a"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">authoritative-source-url</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">The authoritative location in which the image is published</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>TBD</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">distribution-scope</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Intended scope of distribution for image. Possible values are private, authoritive-source-only, restricted, or public</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>private</em></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_action_oriented_labels">Action-oriented labels</h4>
<div id="label_action" class="paragraph">
<p>Most action-oriented labels will be a used in the context of a docker command in order for the container to behave in a desired
way.  The following table describes the defined action-oriented labels.</p>
</div>
<table class="tableblock frame-all grid-all spread">
<caption class="title">Table 3. Action-oriented labels</caption>
<colgroup>
<col style="width: 33.3333%;">
<col style="width: 33.3333%;">
<col style="width: 33.3334%;">
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Label</th>
<th class="tableblock halign-left valign-top">Description</th>
<th class="tableblock halign-left valign-top">Example</th>
</tr>
</thead>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">debug</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command to run the image with debugging turned on</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>tbd</em></p></td>
</tr>
</tfoot>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">help</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command to run the help command of the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>tbd</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">run</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command to run the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"docker run -d --privileged --name NAME --net=host --pid=host -v /etc/pki/rsyslog:/etc/pki/rsyslog -v /etc/rsyslog.conf:/etc/rsyslog.conf -v /etc/sysconfig/rsyslog:/etc/sysconfig/rsyslog -v /etc/rsyslog.d:/etc/rsyslog.d -v /var/log:/var/log -v /var/lib/rsyslog:/var/lib/rsyslog -v /run:/run -v /etc/machine-id:/etc/machine-id -v /etc/localtime:/etc/localtime -e IMAGE=IMAGE -e NAME=NAME --restart=always IMAGE /bin/rsyslog.sh"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">uninstall</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command to uninstall the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"docker run --rm --privileged -v /:/host -e HOST=/host -e IMAGE=IMAGE -e NAME=NAME IMAGE /bin/uninstall.sh"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">install</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command to install the image</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>"docker run --rm --privileged -v /:/host -e HOST=/host -e IMAGE=IMAGE -e NAME=NAME IMAGE /bin/install.sh"</em></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">stop</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Command to execute before stopping container</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>tbd</em></p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_recommended_labels_for_your_project">Recommended labels for your project</h4>
<div class="paragraph">
<p>Labels are critical to properly identifying your image and influencing how it runs.  For the purposes of
identification, we recommend that you at least use the following labels:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>name</p>
</li>
<li>
<p>version</p>
</li>
<li>
<p>release</p>
</li>
<li>
<p>architecture</p>
</li>
<li>
<p>vendor</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>And for actionable labels, we recommend you use at least the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>RUN</p>
</li>
<li>
<p>INSTALL</p>
</li>
<li>
<p>UNINSTALL</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>These three are the most critical for ensuring that users run the image in the manner you wish.  Furthermore,
tools developed to read and act upon this meta data will work correctly.</p>
</div>
<div class="paragraph">
<p>In the case that you provide a help file that does not follow the standard of a man page, then the HELP label would also
be prudent.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_template">Template</h3>

</div>
<div class="sect2">
<h3 id="_starting_your_application">Starting your application</h3>
<div class="paragraph">
<p>Generally the CMD instruction in the Dockerfile is used by docker to start your application
when the image or container is started.  In the planning section, we provided some reasoning
for choosing how to  <strong><em><a href="#planning_starting_application">start your application</a></em></strong>.  The following
subsections will show how to implement each choice in your Dockerfile.</p>
</div>
<div class="sect3">
<h4 id="_calling_the_binary_directly">Calling the binary directly</h4>
<div class="paragraph">
<p>Being the simplest of the choices, you simply need to call the binary using the CMD instruction or
define an ENTRYPOINT in your Dockerfile.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CMD ["/usr/bin/some_binary"]</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_using_the_cmd_instruction">Using the CMD Instruction</h5>
<div class="paragraph">
<p>With CMD, you can identify the default command to run from the image, along with options you want to pass to it.
If there is no ENTRYPOINT in the Dockerfile, the value of CMD is the command run by default when you start the
container image. If there is an ENTRYPOINT in the Dockerfile, the ENTRYPOINT value is run as the command instead,
with the value of CMD used as options to the ENTRYPOINT command.</p>
</div>
<div class="paragraph">
<p>The CMD instruction can be overridden when you run the image. So, notice the different results from running
mycmd in two different ways:</p>
</div>
<div class="paragraph">
<p>Any time you add an argument to the end of a docker run command, the CMD instruction inside the container is ignored.
So the second example opens a bash shell instead of running the cat command. If you want to assign a command that
is not overridden by options at the end of a docker run command, use the ENTRYPOINT instruction.</p>
</div>
</div>
<div class="sect4">
<h5 id="_using_the_entrypoint_instruction">Using the ENTRYPOINT Instruction</h5>
<div class="paragraph">
<p>Like CMD, the ENTRYPOINT instruction lets you define the command executed when you run the container image but it
cannot be overridden by arguments you put at the end of a docker run line. If your Dockerfile includes an
ENTRYPOINT instruction and there is also a CMD instruction, any arguments on the CMD instruction line are passed to
the command defined in the ENTRYPOINT line.</p>
</div>
<div class="paragraph">
<p>This is the distinct advantage of the ENTRYPOINT instruction over the CMD instruction because the command being run
is not overridden but it can be subsidized.  Suppose you have an ENTRYPOINT instruction that displays two files.
You could easily add an additional file to be displayed by adding it to the docker run command.</p>
</div>
<div class="paragraph">
<p>You can override the ENTRYPOINT command by defining a new entrypoint with the --entrypoint="" option on the docker
command line.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="creating_using_a_script">Using a script</h4>
<div class="paragraph">
<p>Using a script to start an application is very similar to calling the binary directly. Again, you
use the CMD instruction but instead of pointing at the binary you point at your script that was
injected into the image.  The <em>registry.access.redhat.com/rhel7/rsyslog</em> image uses a script
to start the rsyslogd application. Lets look at the two relevant instructions in its Dockerfile
that make this happen.</p>
</div>
<div class="paragraph">
<p>The following instruction injects our script (rsyslog.sh) into the image in the <em>bin</em> dir.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>ADD rsyslog.sh /bin/rsyslog.sh</code></pre>
</div>
</div>
<div class="paragraph">
<p>The contents of the script are as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>#!/bin/sh
# Wrapper to start rsyslog.d with appropriate sysconfig options

echo $$ &gt; /var/run/syslogd.pid

source /etc/sysconfig/rsyslog
exec /usr/sbin/rsyslogd -n $SYSLOGD_OPTIONS</code></pre>
</div>
</div>
<div class="paragraph">
<p>Notice how the script does in fact handle environment variables by sourcing the <em>/etc/sysconfig/rsyslog</em>
file. And the CMD instruction simply calls the script.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>CMD [ "/bin/rsyslog.sh" ]</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="creating_using_systemd">Using systemd "inside the container"</h4>
<div class="paragraph">
<p>Extending our example from <a href="#creating_using_a_script">starting an application with a script</a>, the rsyslog
image was started with a script.  We could easily use systemd to start the application.  To use systemd
to start a service that has a unit file, we need to tell systemd to enable the service and then let the
init process handle the rest. So instead of the ADD instruction used earlier, we would use a RUN
instruction to enable the service.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>RUN systemctl enable rsyslog</code></pre>
</div>
</div>
<div class="paragraph">
<p>And then we need to change the CMD instruction to call <em>/usr/sbin/init</em> to let systemd take over.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>RUN /usr/sbin/init</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_using_systemd_to_control_containers">Using systemd to control containers</h4>
<div class="paragraph">
<p>The control mechanism for most docker functions is done via the docker commands or something like
the atomic application which simplifies the management of containers and images for users.  But in
a non-development environment, you may wish to treat your containers more like traditional services
or applications.  For example, you may wish to have your containers start in a specific order on
boot-up.  Or perhaps you wish to be able to restart (or recycle) a container because you have changed
its configuration file.</p>
</div>
<div class="paragraph">
<p>There are several approaches to these sorts of function.  You can make sure a specific container
always starts on boot-up using the --restart switch with the docker command line when you initially
run the image.  There are also orchestration platforms like Kubernetes that will allow you to determine the
start up order of containers even when they are distributed.  But in the case where all the containers
reside on a single node, systemd might just be exactly the solution.  Like with traditional services,
systemd is capable of making sure services both start and in the order they are specified.  Moreover,
any issues with startup or the container are logged like any other system service.</p>
</div>
<div class="paragraph">
<p>When using systemd to manage your containers, you are really using systemd to call docker commands (and
subsequently the docker daemon) to perform the actions.  Therefore, once you commit to using systemd
to control a container, you will need to make sure that all start, stop, and restart actions are
conducted with systemd.  Failure to do so essentially decouples the docker daemon and systemd causing
systemd to be out of sync.</p>
</div>
<div class="paragraph">
<p>In review, systemd is a good solution for:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>host system services such as agents and long-running services</p>
</li>
<li>
<p>logging via journald</p>
</li>
<li>
<p>service dependant management</p>
</li>
<li>
<p>traditional service management vis <em>systemctl</em></p>
</li>
<li>
<p>multi-container applications with dependencies on the same node</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The configuration file below is a sample service file that can be used and edited to control your image or
container.  In the [Unit] section, you can declare other services needed by your image including the cases where
those services are also images.</p>
</div>
<div class="listingblock">
<div class="title">Sample template for a systemd service file</div>
<div class="content">
<pre class="highlight"><code>[Unit]
After=docker.service
Requires=docker.service
PartOf=docker.service
After=[cite another service]
Wants=[cite another service]

[Service]
EnvironmentFile=[path to configuration file]
ExecStartPre=-[command to execute prior to starting]
ExecStart=[command to execute for start]
ExecStartPost=/usr/bin/sleep 10
ExecStop=[command to execute for stop]
Restart=always

[Install]
WantedBy=docker.service</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the [Service] section, you can also declare the actual commands that should be run prior to start, in the
case of start, and in the case of stop.  These commands can either be straight base commands or docker run (or stop)
commands as well.  Finally, if you are using a well made image that contains labels like STOP or RUN, you
could also use the atomic command.  For example, a start command could simply be:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code>atomic run &lt;image_name&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>This works because the actual docker command to run that image is part of the image&#8217;s metadata and atomic is
capable of extracting it.</p>
</div>
<div class="paragraph">
<p>The [Service] section also has an option for EnvironmentFile.  In a traditional, non-containerized systemd service,
this configuration file resides in <em>/etc/sysconfig/&lt;service_name&gt;</em>.  In the case of a containerized application,
these configuration files are not always configurable and therefore do not reside on the host&#8217;s filesystem.  And
in the case of where they are configurable, the EnvironmentFile is usually more important to how the service
application is started.  If you are <a href="#planning_use_systemd">starting the application</a> within an image
with systemd, then systemd will use <em>/etc/sysconfig/&lt;service_name&gt;</em> within the image itself.</p>
</div>
<div class="paragraph">
<p>For more information on writing unit files see <a href="https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/System_Administrators_Guide/sect-Managing_Services_with_systemd-Unit_Files.html">Managing Systemd unit files</a>.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_help_file">Creating a Help file</h3>
<div class="paragraph">
<p>You can now provide a man-like help file with your images that allow for users to have a deeper understanding of your
image.  This function now allows you to provide a:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>more verbose description of the what the image is and does</p>
</li>
<li>
<p>understanding of how the image should be run</p>
</li>
<li>
<p>description of the security implications inherent in running the image</p>
</li>
<li>
<p>requirement if the image needs to be installed</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The atomic application will allow you to display this help file trivially like so:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-none" data-lang="none"># atomic help &lt;image or container name&gt;</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="_location">Location</h4>
<div class="paragraph">
<p>The help file must be located in the images as /help.1 and in 'man' format.</p>
</div>
</div>
<div class="sect3">
<h4 id="_required_headings">Required headings</h4>
<div class="paragraph">
<p>The following headings are strongly encouraged in the help file for an image.</p>
</div>
<div class="sect4">
<h5 id="_description">DESCRIPTION</h5>
<div class="paragraph">
<p>Describe in greater detail the role or purpose of the image.  This can include more specifics about the
packages that make up the image.  You can also describe whether image is meant to be interactive
or more service oriented.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_usage">USAGE</h4>
<div class="paragraph">
<p>Describe how to run the image as a container and what factors might influence the behaviour of the image
itself.</p>
</div>
</div>
<div class="sect3">
<h4 id="_history">HISTORY</h4>
<div class="paragraph">
<p>Similar to a Changelog of sorts which can be as detailed as the maintainer desires.</p>
</div>
</div>
<div class="sect3">
<h4 id="_optional_headings">Optional headings</h4>
<div class="paragraph">
<p>Use the following sections in your help file when applicable.</p>
</div>
<div class="sect4">
<h5 id="_labels_2">Labels</h5>
<div class="paragraph">
<p>Describe the labels you use and why when applicable.  Specifically focus any action-oriented labels like RUN, INSTALL, and
UNINSTALL.</p>
</div>
</div>
<div class="sect4">
<h5 id="_security_implications">Security Implications</h5>
<div class="paragraph">
<p>If you image uses any privileges that you want to make the user aware of, be sure to document which ones are used and optionally
why.</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_sample_template">Sample template</h4>
<div class="paragraph">
<p>We recommend writing the help file in the <a href="https://help.github.com/articles/markdown-basics/">markdown</a> language and then
converting it to the man format.  This is handy because github can natively display markdown so the help file can be used
in multiple ways.</p>
</div>
<div class="listingblock">
<div class="title">Sample help template in markdown format</div>
<div class="content">
<pre class="highlight"><code class="language-markdown" data-lang="markdown">% IMAGE_NAME(1)
% MAINTAINER
% DATE


# DESCRIPTION
Describe in greater detail the role or purpose of the image.  This can include more specifics about the
packages that make up the image.  You can also describe whether image is meant to be interactive
or more service oriented.

# USAGE
Describe how to run the image as a container and what factors might influence the behaviour of the image
itself. For example:

To set up the host system for use by the XYZ container, run:

  atomic install XYZimage

To run the XYZ container (after it is installed), run:

  atomic run XYZimage

To remove the XYZ container (not the image) from your system, run:

  atomic uninstall XYZimage

To upgrade the XYZ container from your system, run:

  atomic upgrade XYZimage

# LABELS
Describe LABEL settings (from the Dockerfile that created the image) that contains pertinent information.
For containers run by atomic, that could include INSTALL, RUN, UNINSTALL, and UPDATE LABELS. Others could
include BZComponent, Name, Version, Release, and Architecture.

# SECURITY IMPLICATIONS
If you expose ports or run with privileges, it would be warranted to briefly note those and provide
an explanation if needed.

# HISTORY
Similar to a Changelog of sorts which can be as detailed as the maintainer wishes.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_example_help_file_for_the_rsyslog_container">Example help file for the rsyslog container</h4>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-markdown" data-lang="markdown">% RSYSLOG (1) Container Image Pages
% Stephen Tweedie
% January 27, 2016

# NAME
rsyslog \- rsyslog container image

# DESCRIPTION

The rsyslog image provides a containerized packaging of the rsyslogd daemon. The rsyslogd daemon is a
utility that supports system message logging. With the rsyslog container installed and running, you
can configure the rsyslogd service directly on the host computer as you would if the daemon were
not containerized.

You can find more information on the rsyslog project from the project Web site (http://www.rsyslog.com/doc).

The rsyslog image is designed to be run by the atomic command with one of these options:

`install`

Sets up the container to access directories and files from the host system to use for rsyslogd configuration,
logging, log rotation, and credentials.

`run`

Starts the installed container with selected privileges to the host and with logging-related files and
directories bind mounted inside the container. If the container stops, it is set to always restart.

`uninstall`

Removes the container from the system. This removes the syslog logrotate file, leave all other files
and directories associated with rsyslogd on the host system.

Because privileges are opened to the host system, the running rsyslog container can gather log messages
from the host and save them to the filesystem on the host.

The container itself consists of:
    - rhel7/rhel base image
    - rsyslog RPM package

Files added to the container during docker build include: /bin/install.sh, /bin/rsyslog.sh, and /bin/uninstall.sh.

# "USAGE"
To use the rsyslog container, you can run the atomic command with install, run, or uninstall options:

To set up the host system for use by the rsyslog container, run:

  atomic install rhel7/rsyslog

To run the rsyslog container (after it is installed), run:

  atomic run rhel7/rsyslog

To remove the rsyslog container (not the image) from your system, run:

  atomic uninstall rhel7/rsyslog

# LABELS
The rsyslog container includes the following LABEL settings:

That atomic command runs the docker command set in this label:

`INSTALL=`

  LABEL INSTALL="docker run --rm --privileged -v /:/host \
  -e HOST=/host -e IMAGE=IMAGE -e NAME=NAME \
  IMAGE /bin/install.sh"

  The contents of the INSTALL label tells an `atomic install rhel7/rsyslog` command to remove the container
  after it exits (--rm), run with root privileges open to the host, mount the root directory (/) from the hos on
  the /host directory within the container, set the location of the host file system to /host, set the name of
  the image and run the install.sh script.

`RUN=`

  LABEL RUN="docker run -d --privileged --name NAME \
  --net=host --pid=host \
  -v /etc/pki/rsyslog:/etc/pki/rsyslog \
  -v /etc/rsyslog.conf:/etc/rsyslog.conf \
  -v /etc/sysconfig/rsyslog:/etc/sysconfig/rsyslog \
  -v /etc/rsyslog.d:/etc/rsyslog.d \
  -v /var/log:/var/log \
  -v /var/lib/rsyslog:/var/lib/rsyslog \
  -v /run:/run \
  -v /etc/machine-id:/etc/machine-id:ro \
  -v /etc/localtime:/etc/localtime:ro \
  -e IMAGE=IMAGE -e NAME=NAME \
  --restart=always IMAGE /bin/rsyslog.sh"

  The contents of the RUN label tells an `atomic run rhel7/rsyslog` command to open various privileges to the host
  (described later), mount a variety of host files and directories into the container, set the name of the container,
  set the container to restart automatically if it stops, and run the rsyslog.sh script.


`UNINSTALL=`

  LABEL UNINSTALL="docker run --rm --privileged -v /:/host \
  -e HOST=/host -e IMAGE=IMAGE -e NAME=NAME \
  IMAGE /bin/uninstall.sh"

  The contents of the UNINSTALL label tells an `atomic uninstall rhel7/rsyslog` command to uninstall the rsyslog
  container. Stopping the container in this way removes the container, but not the rsyslog image from your system.
  Also, uninstalling leaves all rsyslog configuration files and log files intact on the host (only removing the
  syslog logrotate file).

`BZComponent=`

The bugzilla component for this container. For example, "BZComponent="rsyslog-docker".

`Name=`

The registry location and name of the image. For example, "Name="rhel7/rsyslog":

`Version=`

The Red Hat Enterprise Linux version from which the container was built. For example, "Version="7.2".

`Release=`

The specific release number of the container Release="12.1.a":

`Architecture=`

The machine architecture associated with the Red Hat Enterprise Linux release. For example, "Architecture="x86_64"

When the atomic command runs the rsyslog container, it reads the command line associated with the selected option
from a LABEL set within the Docker container itself. It then runs that command. The following sections detail
each option and associated LABEL:

.SH "SECURITY IMPLICATIONS"
The rsyslog container is what is referred to as a super-privileged container. It is designed to have almost complete
access to the host system as root user. The following docker command options open selected privileges to the host:

`-d`

Runs continuously as a daemon process in the background

`--privileged`

Turns off security separation, so a process running as root in the container would have the same access to the
host as it would if it were run directly on the host.

`--net=host`

Allows processes run inside the container to directly access host network interfaces

`--pid=host`

Allows processes run inside the container to see and work with all processes in the host process table

`--restart=always`

If the container should fail or otherwise stop, it would be restarted

.SH "HISTORY"
Similar to a Changelog of sorts which can be as detailed as the maintainer wishes.

.SH "AUTHORS"

Stephen Tweedie</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_converting_markdown_to_man_format">Converting markdown to man format</h4>
<div class="paragraph">
<p>There are several methods for converting markdown format to man format.  One prevalent method is to use go-md2man supplied
by the golang-github-cpuguy83-go-md2man package.  To convert from markdown to man using this utility, you do as follows:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-none" data-lang="none"># go-md2man -in path_to_man_file -out output_file</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_creating_a_changelog">Creating a Changelog</h3>

</div>
<div class="sect2">
<h3 id="_verifying_dockerfile_linter">Verifying Dockerfile (linter)</h3>

</div>
<div class="sect2">
<h3 id="_dockerfiles">Dockerfiles</h3>
<div class="paragraph">
<p>The Dockerfiles for many of the public images are hosted in git repositories where users can view
them.  This also allows users to customize them as well.</p>
</div>
<div class="paragraph">
<p>It is also good practice to include the Dockerfile in the image itself.  Some distributions have begun to
include an image&#8217;s Dockerfile in the directory <em>/root/buildinfo</em>.  Consider following the same
approach to make sure your Dockerfiles can be easily found.</p>
</div>
<div class="paragraph">
<p>OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD - OLD -</p>
</div>
</div>
<div class="sect2">
<h3 id="_dockerfiles_2">Dockerfiles</h3>
<div class="sect3">
<h4 id="_location_2">Location</h4>
<div class="paragraph">
<p>Upstream Dockerfiles should be hosted in a public GIT repository, for example <a href="https://github.com">GitHub</a>. Ideally, the repository should be created under the organization relevant to a particular project. For example, <a href="http://www.softwarecollections.org">Software Collections</a> Dockerfiles are available under the GitHub <a href="https://github.com/sclorg">sclorg</a> organization.</p>
</div>
</div>
<div class="sect3">
<h4 id="_images">Images</h4>
<div class="paragraph">
<p>Upstream Docker images, such as CentOS and Fedora base images and layered images based on these, should be publicly available on <a href="https://registry.hub.docker.com/">Docker Hub</a>.</p>
</div>
<div class="paragraph">
<p>For details on using the Docker Hub registry, see <a href="https://docs.docker.com/userguide/dockerimages/">Docker User Guide</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="_content">Content</h4>
<div class="paragraph">
<p>Docker is a platform that enables applications to be quickly assembled from components. When creating Docker images, think about the added value you can provide potential users with. The intention should always be bringing some added functionality on top of plain package installation.</p>
</div>
<div class="paragraph">
<p>As an example, take this <a href="https://github.com/docker-library/wordpress/blob/618490d4bdff6c5774b84b717979bfe3d6ba8ad1/apache/Dockerfile">Word Press Dockerfile</a>. After running the image and linking it with a database image such as mysql, you will get a fully operational Word Press instance. In addition, you can also specify an external database.</p>
</div>
<div class="paragraph">
<p>This exactly is the purpose of using Docker images; instead of laborious installation and configuration of separate components, you simply pull an image from a registry, acquiring a set of tools ready to be used right out-of-the-box.</p>
</div>
</div>
<div class="sect3">
<h4 id="_enabling_necessary_repositories">Enabling Necessary Repositories</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="_users">Users</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="_working_directory">Working Directory</h4>
<div class="paragraph">
<p>TBD</p>
</div>
</div>
<div class="sect3">
<h4 id="_exposing_ports">Exposing Ports</h4>
<div class="paragraph">
<p>The EXPOSE instruction declares the ports on which a container will listen for incoming connections. You should specify ports your application commonly uses; for example, as seen in this <a href="https://github.com/openshift/mysql/blob/master/5.5/Dockerfile">mysql</a> example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre>EXPOSE 3306</pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<div class="title">Important</div>
</td>
<td class="content">
The TCP/IP port numbers below 1024 are special in that normal users are not allowed to bind on them.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Therefore, for example for Apache server, ports 8080 or 8433 (HTTP or HTTPS) should be exposed. Otherwise, only the root user will be allowed to run Apache server inside a container.</p>
</div>
</div>
<div class="sect3">
<h4 id="_logging">Logging</h4>
<div class="paragraph">
<p>TBD</p>
</div>
<div class="paragraph">
<p>&#8230;&#8203;</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_references">References</h3>
<div class="paragraph">
<p>Please see the following resources for more information on the Docker container technology and project-specific guidelines.</p>
</div>
<div class="paragraph">
<p><a href="http://docs.docker.com/">Docker Documentation</a>&#8201;&#8212;&#8201;Detailed information about the Docker platform.</p>
</div>
<div class="paragraph">
<p><a href="https://github.com/openshift/openshift-docs/blob/master/creating_images/guidelines.adoc#openshift-specific-guidelines">OpenShift Guidelines</a>&#8201;&#8212;&#8201;Guidelines for creating images specific to the OpenShift project.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2016-05-16 09:59:42 EDT
</div>
</div>
</body>
</html>